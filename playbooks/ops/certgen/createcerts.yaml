- name: Deploy gninx ingress controller if not already exists
  when: ISK8S == true
  block:
  - name: Check status of nginx ingress controller
    k8s_info:
      kubeconfig: "{{ pjroot }}/vars/kubeconfig/config"
      namespace: "ingress-nginx"
      name: "ingress-nginx-controller"
      kind: Service
    register: nginx

  - name: Get public ip address
    when: (nginx.resources|length) > 0
    set_fact:
      K8SIP: "{{ nginx.resources[0].status.loadBalancer.ingress[0].ip }}"

  - name: Deploy nginx ingress controller if not already exists
    when: (nginx.resources|length) == 0
    k8s:
      kubeconfig: "{{ pjroot }}/vars/kubeconfig/config"
      state: present
      src: "{{ pjroot }}/playbooks/ops/certgen/templates/ingresscontroller.yaml"

  - name: Wait for ingress controller to be ready
    when: (nginx.resources|length) == 0
    k8s_info:
      kubeconfig: "{{ pjroot }}/vars/kubeconfig/config"
      namespace: "ingress-nginx"
      name: "ingress-nginx-controller"
      kind: Deployment
      wait: yes
      wait_condition:
        type: "Available"
        status: "True"
        reason: "MinimumReplicasAvailable"
      wait_sleep: 3
      wait_timeout: 90

  - name: Now try to get nginx ingress controller external IP address
    when: (nginx.resources|length) == 0
    k8s_info:
      kubeconfig: "{{ pjroot }}/vars/kubeconfig/config"
      namespace: "ingress-nginx"
      name: "ingress-nginx-controller"
      kind: Service
    register: nginx

  - name: Get public ip address
    when: K8SIP is not defined and nginx.resources is defined
    set_fact:
      K8SIP: "{{ nginx.resources[0].status.loadBalancer.ingress[0].ip }}"

- name: "Ensure certificate directory is clean"
  file:
    path: "{{ pjroot }}/vars/keyfiles"
    state: "{{ item }}"
  with_items:
    - "absent"
    - "directory"

- name: Make sure that run directory exists
  file:
    path: "{{ pjroot }}/vars/run"
    state: "directory"

- name: Remove the cached node var file
  file:
    path: "{{ pjroot }}/vars/{{ item }}"
    state: "absent"
  with_items:
    - "key_vars.json"
    - "node_vars.json"

- name: "Check if user provided crypto config file exists"
  stat:
    path: "{{ pjroot }}/vars/my-crypto-config.yaml"
  register: cryc

- name: Use the provide crypto-config.yaml file
  copy:
    src: "{{ pjroot }}/vars/my-crypto-config.yaml"
    dest: "{{ pjroot }}/vars/crypto-config.yaml"
  when: cryc.stat.exists == true

- name: Create crypto-config file
  template:
    src: "{{ pjroot }}/playbooks/ops/certgen/templates/crypto-config.j2"
    dest: "{{ pjroot }}/vars/crypto-config.yaml"
  when: cryc.stat.exists == false

- name: Set effecctive release
  set_fact:
    truerelease: "{{ (fabric.release == '1.4') | ternary('1.4.6', fabric.release) }}"

- name: Create config tx file
  template:
    src: "{{ pjroot }}/playbooks/ops/certgen/templates/configtx.j2"
    dest: "{{ pjroot }}/vars/configtx.yaml"

- name: Create certs using openssl
  include_tasks: "orgkeygen.yaml"
  loop: "{{ allorgs }}"
  loop_control:
    loop_var: org

- name: Create certs and channel artifacts script
  template:
    src: "{{ pjroot }}/playbooks/ops/certgen/templates/certtxgen.j2"
    dest: "{{ pjroot }}/vars/run/certtxgen.sh"
    mode: +x

- name: Use fabric tools container to create channel artifacts
  command: >-
    docker run --rm --name tools
    -v /var/run/:/host/var/run
    -v {{ hostroot}}/vars:/etc/hyperledger/fabric
    hyperledger/fabric-tools:{{ fabric.release }} /etc/hyperledger/fabric/run/certtxgen.sh

- name: Upload gensis block for orderers
  when: ISK8S == true and (ordererorgs|length > 0)
  k8s:
    kubeconfig: "{{ pjroot }}/vars/kubeconfig/config"
    state: present
    definition:
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: "genesis-blocks"
        namespace: "{{ NETNAME }}"
      binaryData:
        genesis.block: >-
          {{ lookup('file', pjroot+'/vars/genesis.block', errors='ignore') | b64encode }}

- name: Package all the certs to one file
  archive:
    path: "{{ pjroot }}/vars/keyfiles"
    dest: "{{ pjroot }}/vars/certs.tgz"
